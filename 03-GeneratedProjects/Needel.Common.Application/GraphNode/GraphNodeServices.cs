#region Copyright info
//-----------------------------------------------------------------------
// <copyright file="GraphNode" company="Company">
//     Copyright (c) 2020. Company. All Rights Reserved.
//     Copyright (c) 2020. Company. Todos los derechos reservados.
//
//     .en This code has been generated by a tool, please don't modify this file or  
//     you will lost all your modifications in the next regeneration.
//      The original t4 template to get this file is " ApplicationEntityServicesBaseCT.tt" with "public class ApplicationEntityServicesBaseCT : Template"
// 
//     .es Este código ha sido generado por una herramienta, por favor no modifique este fichero
//     o perdera las modificaciones al regenerar este fichero.
//      La plantilla con que se ha generado este fichero es "ApplicationEntityServicesBaseCT.tt" con "public class ApplicationEntityServicesBaseCT : Template"
//
// </copyright>
//-----------------------------------------------------------------------
#endregion

namespace Needel.Common.Application
{
    #region usings 

    using System;
    using System.Collections.Generic;
    using System.Linq;
    using System.Linq.Expressions;
    using System.Text;
    using System.Globalization;
    using System.Reflection;
    using System.Data.Entity;
    using System.Configuration;

    using Microsoft.Practices.Unity;

    using Inflexion2.Domain;
    using Inflexion2.Application;
    using Inflexion2;
    using Inflexion2.Domain.Specification;
    using Inflexion2.Logging;
    using Inflexion2.Data;
    using Inflexion2.Resources;

    using Needel.Common.Application.Dtos;
    using Needel.Common.Application;    
    using Needel.Common.Domain;
    using Needel.Common.Infrastructure;
    using Needel.Common.Infrastructure.Resources;
// Common

    using System.ComponentModel.DataAnnotations;
    using System.Collections.ObjectModel;
    #endregion

    /// <summary>
    /// .en generated with ServiceHeaderClass.tt
    /// Administration services of the entity GraphNode.
    /// .es geenrado con la plantilla ServiceHeaderClass.tt
    /// Representa los servicios de administración de la entidad GraphNode.
    /// </summary>
    /// <remarks>
    /// .en Create an object of type <see cref="GraphNode"/>.
    /// .es Crea un objeto <see cref="GraphNode"/>.
    ///  permanent guid = 
    /// </remarks>
    public partial class GraphNodeServices : Inflexion2.Application.EfApplicationServicesBase<GraphNodeDto, GraphNode, Int32>, IGraphNodeServices
    {

        #region Fields
        // Mappers of related entitites
        new IGraphNodeRepository EntityRepository;
        #endregion

        #region Constructors
        /// <summary>
        /// .es Inicializa una nueva instancia de la clase <see cref="T:GraphNode>Service"/>.
        /// </summary>
        /// <remarks>
        /// .es Constructor de la clase <see cref="T:GraphNodeServices"/>.
        /// </remarks>
        public GraphNodeServices() : base()
        {
            this.EntityMapper = new GraphNodeMapper();
            this.EntityRepository = ApplicationLayer.IocContainer.Resolve<IGraphNodeRepository>();
        }
        #endregion

        #region Create Method
        // from template Application\UpdateBase\I2ServiceRegionCreateMethod.tt

        /// <summary>
        /// Crea una entidad GraphNode.
        /// </summary>
        /// <param name="graphNodeDto">
        /// DTO que contiene la información para crear la entidad.
        /// </param>
        /// <returns>
        /// El identificador de la entidad creada.
        /// </returns>
        public override Int32 Create(GraphNodeDto graphNodeDto)
        {

            #region Preconditions

            // Comprobar el DTO de entrada.
            Guard.ArgumentIsNotNull(
                                    graphNodeDto,
                                    string.Format(
                                                    FrameworkResource.DataTransferObjectIsNull,
                                                    CommonResources.GraphNodeAlias));
            // Comprobar los campos mandatory dentro del DTO.
            Guard.ArgumentNotNullOrEmpty(
                                        graphNodeDto.Name,
                                        string.Format(
                                                        FrameworkResource.PropertyRequired,
                                                        CommonResources.GraphNode_NameAlias, 
                                                        CommonResources.GraphNodeAlias)
                                        );

            #endregion

            // .en the dto has to be transient, so the Id has to have a default value.
            // .es el dto debe corresponder a un transient por lo que el id debe tener el valor por defecto
            Guard.Against<ArgumentException>(graphNodeDto.Id != default(Int32),                                    
                                                    string.Format(
                                                                FrameworkResource.IsNotTransient,
                                                                CommonResources.GraphNodeAlias
                                                                    )
                                            );

            var leftNodes = new System.Collections.Generic.List<GraphNode>();


            GraphNode graphNode = GraphNodeFactory.Create
            (
                graphNodeDto.Name
            );//**
            this.EntityRepository.Add(graphNode);
            this.Commit();

            return graphNode.Id;
        }
        #endregion

        #region Service Delete

        /// <summary>
        /// .es Elimina una determinada entidad GraphNode.
        /// </summary>
        /// <param name="id">
        /// Identificador de la entidad que se va a eliminar.
        /// </param>
        /// <returns>
        /// Es <b>true</b> si la eliminación ha sido correcta; en caso contrario <b>false</b>.
        /// </returns>
        public override bool Delete(Int32 id)
        {
             IEnumerable<GraphNode> results = this.EntityRepository.GetFilteredElements(u => u.Id == id);
            GraphNode graphNode2Delete = results.First();
            if (!graphNode2Delete.CanBeDeleted())
            {
                return false;
            }


            try
            {
                this.EntityRepository.Remove(graphNode2Delete);
                this.Commit();
            }
            catch (Exception)
            {

                return false;
            }

            return true;
        }

        /// <summary>
        /// .es Elimina las entidades GraphNode seleccionadas por los ids del parametro.
        /// </summary>
        /// <param name="graphNodeIds"></param>
        /// <returns></returns>
        public override IEnumerable<Int32> Delete(IEnumerable<Int32> graphNodeIds)
        {
            foreach (var id in graphNodeIds)
            {
                if ((!Delete(id)))
                {
                    yield return id;
                }
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="specificationDto"></param>
        /// <returns></returns>
        public override IEnumerable<Int32> Delete(SpecificationDto specificationDto)
        {
            var dtos2delete = GetFilteredEntities(specificationDto).Select(c => c.Id).ToList();
            return Delete(dtos2delete);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <returns></returns>
        public override IEnumerable<Int32> DeleteAll()
        {
            List<Int32> result = new List<Int32>();

            try
            {
                var entities = this.EntityRepository.RemoveAll();
                this.Commit();
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return result.ToArray();
        }




        #endregion


        #region GetAll Method
        /// <summary>
        /// .es Recupera todas las entidades GraphNode.
        /// </summary>
        /// <returns>
        /// Todas las entidades GraphNode.
        /// </returns>
        public override IEnumerable<GraphNodeDto> GetAll()
        {
            // .en answer variable
            // .es Variable de respuesta.
            // list new cosntructor (int32) initial size http://msdn.microsoft.com/en-us/library/dw8e0z9z(v=vs.110).aspx
            var result = new List<GraphNodeDto>(0);

            try
            {
                var entities = this.EntityRepository.GetAll();
                // Mapeamos los datos.
                entities.ToList()
                        .ForEach(entity =>
                        {
                            var entityDto = this.EntityMapper.EntityMapping(entity);
                            result.Add(entityDto);
                        });

                // Confirmamos la transacción.
                this.Commit();
                
            }
            catch (Exception ex)
            {
                throw ex;
            }

            // Devolver resultado.
            return result;
        }

        /// <summary>
        /// .es Recupera todas las instancias de GraphNode excepto la indicada por el parametro. 
        /// </summary>
        /// <param name="graphNodeId">.es Entidad a evitar.</param>
        /// <returns></returns>
        public override IEnumerable<GraphNodeDto> GetAllExceptThis(Int32 graphNodeId)
        {
            try
            {
                List<GraphNodeDto> result = new List<GraphNodeDto>(0);

                 IEnumerable<GraphNode> entities = this.EntityRepository.GetAllExceptThis(graphNodeId);

                // Mapeamos los datos.
                entities.ToList()
                        .ForEach(entity =>
                        {
                            var entityDto = this.EntityMapper.EntityMapping(entity);
                            result.Add(entityDto);
                        });

                // Confirmamos la transacción.
                this.Commit();

                // Devolver el resultado.
                return result;
            }
            catch (Exception ex)
            {
                throw ex;
            }
        }

        /// <summary>
        /// Get all no related objects
        /// </summary>
        /// <param name="graphNodeId"></param>
        /// <returns></returns>
        public IEnumerable<GraphNodeDto> GetAllExceptIdAndRelated(Int32 graphNodeId)
        {
            try
            {
                List<GraphNodeDto> result = new List<GraphNodeDto>(0);

                 IEnumerable<GraphNode> entities = this.EntityRepository.GetAllExceptIdAndRelated(graphNodeId);

                // Mapeamos los datos.
                entities.ToList()
                        .ForEach(entity =>
                        {
                            var entityDto = this.EntityMapper.EntityMapping(entity);
                            result.Add(entityDto);
                        });

                // Confirmamos la transacción.
                this.Commit();

                // Devolver el resultado.
                return result;
            }
            catch (Exception ex)
            {
                throw ex;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="graphNodeIds"></param>
        /// <returns></returns>
        public override IEnumerable<GraphNodeDto> GetSelectedThese(IEnumerable<Int32> graphNodeIds)
        {
            try
            {
                List<GraphNodeDto> result = new List<GraphNodeDto>(0);

                IEnumerable<GraphNode> entities = this.EntityRepository.GetSelectedThese(graphNodeIds);

                // Mapeamos los datos.
                entities.ToList()
                        .ForEach(entity =>
                        {
                            var entityDto = this.EntityMapper.EntityMapping(entity);
                            result.Add(entityDto);
                        });

                // Confirmamos la transacción.
                this.Commit();

                // Devolver el resultado.
                return result;
            }
            catch (Exception ex)
            {
                throw ex;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="graphNodeIds"></param>
        /// <returns></returns>
        public override IEnumerable<GraphNodeDto> GetAllExceptThese(IEnumerable<Int32> graphNodeIds )
        {
            IEnumerable<GraphNode> entities;
            try
            {
                entities = this.EntityRepository.GetAllExceptThese(graphNodeIds);
                this.Commit();
            }
            catch (Exception ex)
            {
                throw ex;
            }

            // Mapeamos los datos. 
            foreach (var entity in entities)
            {
                yield return this.EntityMapper.EntityMapping(entity);
            }
        }
        #endregion


        #region service GetById
        /// <summary>
        /// .es Recupera una entidad GraphNode mediante su identificador correspondiente.
        /// </summary>
        /// <param name="id">
        /// .es Identificador de la entidad que se va a recuperar.
        /// </param>
        /// <returns>
        /// La entidad GraphNode recuperada o valor nulo si no se encuentra.
        /// </returns>
        public override GraphNodeDto GetById(Int32 id)
        {
            // Variable de respuesta.
            GraphNodeDto entityDto = null;

            try
            {               
                var entity = this.EntityRepository.GetAggregateById(id); //TODO: call async
                entityDto = this.EntityMapper.EntityMapping(entity, true, true);

                foreach (var item in entity.LeftNodes)
                {
                    var graphNode = this.EntityMapper.EntityMapping(item);
                    entityDto.LeftNodes.Add(graphNode);
                }

                foreach (var item in entity.RightNodes)
                {
                    var graphNode = this.EntityMapper.EntityMapping(item);
                    entityDto.RightNodes.Add(graphNode);
                }

            }
            catch (Exception ex)
            {
                throw ex;
            }
            finally
            {
                // Confirmamos la transacción.
                this.Commit();
            }

            // Devolvemos el resultado.
            return entityDto;
        }
        #endregion


        #region Service GetPaged
        // code generated from template "ServiceGetPaged.tt"

        /// <summary>
        /// Recupera una lista paginada de entidades GraphNode, según la especificación indicada.
        /// </summary>
        /// <param name="specificationDto">
        /// Especificación que se va a aplicar.
        /// </param>
        /// <returns>
        /// La lista paginada de entidades 'GraphNode', según la especificación indicada.
        /// </returns>
        public override PagedElements<GraphNodeDto> GetPaged(SpecificationDto specificationDto)
        {
            #region Preconditions
            // Comprobar el DTO de entrada.
            Guard.ArgumentIsNotNull(
                                    specificationDto,
                                    string.Format(
                                                  FrameworkResource.EspecificationDataTransferObjectIsNull,
                                                  "Graph Node")); 
            #endregion
            List<GraphNodeDto> result = new List<GraphNodeDto>(0);
            int totalElements = 0;

            try
            {
                // Obtenemos las entidades aplicando la especificación.
                ISpecification<GraphNode> filter =
                    specificationDto.ToSpecification<GraphNode>();

                PagedElements<GraphNode> entities =
                    this.EntityRepository.GetPagedElements(
                                      specificationDto.PageIndex,
                                      specificationDto.PageSize,
                                      filter.IsSatisfiedBy(),
                                                        entity => entity.Id,
                                                        true);
                totalElements = entities.TotalElements;

                // Mapeamos los datos.
                entities.ToList()
                        .ForEach(entity =>
                            {
                                var entityDto = this.EntityMapper.EntityMapping(entity);
                                result.Add(entityDto);
                            });

                // Confirmamos la transacción.
                this.Commit();
                
            }
            catch (Exception ex)
            {
                throw ex;
            }

            // Devolver el resultado.
            return new PagedElements<GraphNodeDto>(result, totalElements);
        }

        ///// <summary>
        ///// 
        ///// </summary>
        ///// <param name="specificationDto"></param>
        ///// <returns></returns>
        //public override IEnumerable<GraphNodeDto> GetFilteredEntities(SpecificationDto specificationDto)
        //{
        //    #region Preconditions
        //    // Comprobar el DTO de entrada.
        //    Guard.ArgumentIsNotNull(
        //                            specificationDto,
        //                            string.Format(
        //                                          FrameworkResource.EspecificationDataTransferObjectIsNull,
        //                                          "GraphNode"));
        //    #endregion
        //
        //    List<GraphNodeDto> result = new List<GraphNodeDto>(0);
        //    try
        //    {
        //        // Obtenemos las entidades aplicando la especificación.
        //        ISpecification<GraphNode> filter = specificationDto.ToSpecification<GraphNode>();
        //        IEnumerable<GraphNode> entities = this.EntityRepository.GetFilteredElements(filter.IsSatisfiedBy());
        //        this.Commit();
        //
        //        entities.ToList()
        //            .ForEach(entity =>
        //            {
        //                var entityDto = this.EntityMapper.EntityMapping(entity);
        //                result.Add(entityDto);
        //            });
        //
        //
        //        return result;
        //    }
        //    catch (Exception ex)
        //    {
        //        throw ex;
        //    }          
        //}


        /// <summary>
        /// 
        /// </summary>
        /// <param name="specificationDto"></param>
        /// <returns></returns>
        public override IEnumerable<GraphNodeDto> GetFiltered(SpecificationDto specificationDto)
        {
            #region Preconditions
            // Comprobar el DTO de entrada.
            Guard.ArgumentIsNotNull(
                                    specificationDto,
                                    string.Format(
                                                  FrameworkResource.EspecificationDataTransferObjectIsNull,
                                                  "GraphNode"));
            #endregion

            List<GraphNodeDto> result = new List<GraphNodeDto>(0);
            try
            {
                // Obtenemos las entidades aplicando la especificación.
                ISpecification<GraphNode> filter = specificationDto.ToSpecification<GraphNode>();
                IEnumerable<GraphNode> entities = EntityRepository.GetFilteredElements(filter.IsSatisfiedBy());

                // Mapeamos los datos.
                entities.ToList()
                        .ForEach(entity =>
                        {
                            var entityDto = this.EntityMapper.EntityMapping(entity);
                            result.Add(entityDto);
                        });

                // Confirmamos la transacción.
                this.Commit();

            }
            catch (Exception ex)
            {
                throw ex;
            }

            // Devolver el resultado.
            return result;
        }

#endregion

        #region Private Duplicated data for precondition methods
        #endregion

        #region internal methods to help create service to map collections froms targets relationships

            /// <summary>
            /// Método encargado de obtener una <see cref="GraphNode"/> a partir 
            /// de su identificador.
            /// </summary>
            /// <remarks>
            /// Sin comentarios adicionales.
            /// </remarks>
            /// <param name="graphNodeId">
            /// Parámetro que indica el identificador único de la entidad a obtener.
            /// </param>
            /// <returns>
            /// Devuelve la entidad <see cref="GraphNode"/> según el identificador.
            /// </returns>
            internal GraphNode GetGraphNodeById(Int32 graphNodeId)
            {
// TODO, completar este metodo y cambiar los parametros añadiendo la entidad sobre la que se aplica.
                //// Unidad de trabajo para el acceso a datos.
                //using (IAdapter unitOfWork = Manager.DefaultController.CreateTransactional())
                //{
                    //// Buscamos la entidad por el Id.
                    //GraphNodeRepository graphNodeRepository = this.RightNodesRepositoryFactory.Create(unitOfWork);
                    //GraphNode graphNode = graphNodeRepository.GetById(graphNodeId);
                    //// Validamos que exista la entidad.
                    //Guard.ArgumentIsNotNull(
                                            //graphNode,
                                            //string.Format(
                                                          //CoreResources.Neutral.NoHayDatosPorId,
                                                          //CommonResources.GraphNodeAlias));
//
                    //// Confirmamos la transacción.
                    //unitOfWork.CommitTransaction();
                    //// Devolvemos la respuesta.
                    //return graphNode;
                //}
                return null;
            } // GetGraphNodeById

        #endregion


        #region update
        // ServiceUpdateMethod.tt
        /// <summary>
        /// Actualiza una determinada entidad GraphNode.
        /// </summary>
        /// <param name="graphNodeDto">
        /// DTO que contiene la información de la entidad que se va a actualizar.
        /// </param>
        /// <returns>
        /// Es <b>true</b> si la actualización ha sido correcta; en caso contrario <b>false</b>.
        /// </returns>
        public override bool Update(GraphNodeDto graphNodeDto)
        {
            #region preconditions
            // Comprobar el DTO de entrada. 
            Guard.ArgumentIsNotNull(
                                    graphNodeDto,
                                    string.Format(
                                                  FrameworkResource.DataTransferObjectIsNull,
                                                  "Graph Node"));
            // en una actualización no comprobamos los campos mandatory.
            #endregion            

            try
            {
                // Obtener y comprobar validez de la inserción a modificar.
                GraphNode entity2Update = this.EntityRepository.GetFilteredElements(t => t.Id == graphNodeDto.Id).Single();
                Guard.ArgumentIsNotNull(
                                        entity2Update,
                                        string.Format(
                                                        FrameworkResource.CanNotUpdateInexistenceEntity,
                                                        "Graph Node"));
                // Comprobar duplicidades;

                    // Actualización de la entidad.
                    entity2Update.Name = graphNodeDto.Name;

                // igualmente hemos de mapear las entidades emparentadas.
                // Para actualizar las relaciones many to many la actualizacion necesita eliminar y crear de nuevo las relaciones existentes
                entity2Update.LeftNodes.Clear();
                foreach (var item in graphNodeDto.LeftNodes)
                {
                    var entity = EntityRepository.GetById(item.Id);
                    entity2Update.AddGraphNodeToLeftNodes(entity);
                }
                // Para actualizar las relaciones many to many la actualizacion necesita eliminar y crear de nuevo las relaciones existentes
                entity2Update.RightNodes.Clear();
                foreach (var item in graphNodeDto.RightNodes)
                {
                    var entity = EntityRepository.GetById(item.Id);
                    entity2Update.AddGraphNodeToRightNodes(entity);
                }

                if (!entity2Update.CanBeSaved())
                {
                    return false;
                }

                this.EntityRepository.Modify(entity2Update);
                this.Commit();
            }
            catch (Exception ex)
            {
                throw ex;
            }

            // Devolvemos el resultado.
            return true;
        }
        #endregion

        #region Add Remove update properties from target relationships
        // Acontinuación escribimos los métodos de las propiedades que provienen de relaciones con otras entidades objetos valor o enumerados y son coleccion.

        /// <summary>
        /// Función encargada de la añadir a la entidad GraphNode una instancia de la propiedad RightNodes de tipo GraphNode
        /// </summary>
        /// <param name="rightNodesDto"> de tipo GraphNode</param>
        /// <returns>
        /// Devuelve <c>True</c> si se ha añadido correctamente.
        /// y <c>False</c> en caso contrario.
        /// </returns>
        public bool AddRightNodes(GraphNodeDto rightNodesDto)
        {
            // TODO: falta completar este metodo
            return false;
        }

        /// <summary>
        /// Función encargada de borrar de la entidad GraphNode una instancia de la colección RightNodes de tipo GraphNode
        /// </summary>
        /// <param name="rightNodesDto"> de tipo GraphNode</param>
        /// <returns>
        /// Devuelve <c>True</c> si se ha añadido correctamente.
        /// y <c>False</c> en caso contrario.
        /// </returns>
        public bool RemoveRightNodes(GraphNodeDto rightNodesDto)
        {
            // TODO: falta completar este metodo
            return false;
        }

        /// <summary>
        /// Función encargada de actualizar de la entidad GraphNode una instancia de la colección RightNodes de tipo GraphNode
        /// </summary>
        /// <param name="rightNodesDto"> de tipo GraphNode</param>
        /// <returns>
        /// Devuelve <c>True</c> si se ha añadido correctamente.
        /// y <c>False</c> en caso contrario.
        /// </returns>
        public bool UpdateRightNodes(GraphNodeDto rightNodesDto)
        {
            // TODO: falta completar este metodo
            return false;
        }


        #endregion

    } // class GraphNode 

} //  Needel.Common.Application

