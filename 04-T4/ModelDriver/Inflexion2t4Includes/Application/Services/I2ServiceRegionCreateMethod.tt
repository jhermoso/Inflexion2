<#@ include file="CreateBase\CreateExecutePreconditions.tt" #>
<#@ include file="CreateBase\CreateDuplicatedDataPrecondition.tt" #>
<#@ include file="CreateBase\CreateRelatedCollections.tt" #>
<#+
public class I2ServiceRegionCreateMethod : Template
{
    // varibles de la plantilla (coinciden con los parametros)
    ClassBaseContext cbc; string projectNamespace; ITree<BoundedContextMetadata> Skt;
    // constructor de la plantilla con parametros
    public I2ServiceRegionCreateMethod(ClassBaseContext  cbc, string projectNamespace, ITree<BoundedContextMetadata> Skt)
        {this.cbc= cbc; this.projectNamespace = projectNamespace;  this.Skt = Skt; }

    public override string TransformText()
    {
     //System.Diagnostics.Debugger.Launch();
     //if (System.Diagnostics.Debugger.IsAttached) System.Diagnostics.Debugger.Break();

        // uso de interfaces en las propiedades y por tanto en metodos
        //por defecto se usan interfaces con nhibernate en cualquiera e sus modalidades y no se usan con entityFramework
        string I = (cbc.diagram.ORM.Contains("ibernate"))?"I":"";
        bool Secured = cbc.MainEntityStereotype.Contains("Bussiness"); // si es una entidad de negocio entoces esta securizada es decir necesita identificación y autorización
        bool Trazable = cbc.MainEntityStereotype.Contains("Bussiness") || cbc.MainEntityStereotype.Contains("Auditable"); // si es una entidad de negocio entoces esta securizada es decir necesita identificación y autorización

        // conceptos propios del projecto en curso
        ProjectConcepts prjCon = new ProjectConcepts(  cbc, projectNamespace, Skt);
        string ResxFileName = prjCon.boundedContextName.Replace(".","") + "Resources"; // este el nombre del fichero que contiene los recursos del contexto limitado en el que nos encontramos.

        var CreateExecutePreconditionsTemplate                   = new CreateExecutePreconditions( cbc, projectNamespace, Skt);                      string CreateExecutePreconditionsTxt                         = CreateExecutePreconditionsTemplate.TransformText();
        var CreateDuplicatedDataPreconditionTemplate             = new CreateDuplicatedDataPrecondition( cbc, projectNamespace, Skt);                string CreateDuplicatedDataPreconditionTxt                   = CreateDuplicatedDataPreconditionTemplate.TransformText();
        var CreateRelatedCollectionsTemplate                     = new CreateRelatedCollections( cbc, projectNamespace, Skt);                        string CreateRelatedCollectionsTxt                           = CreateRelatedCollectionsTemplate.TransformText();

#>
        #region Create Method
        // from template Application\UpdateBase\I2ServiceRegionCreateMethod.tt

        /// <summary>
        /// Crea una entidad <#= cbc.pascalSecureEntityName #>.
        /// </summary>
        /// <param name="<#= cbc.camelSecureEntityName #>Dto">
        /// DTO que contiene la información para crear la entidad.
        /// </param>
<#+if (Secured){ #>        /// <param name="userContextDto"> Información de contexto del usuario. </param><#+ }#>
        /// <returns>
        /// El identificador de la entidad creada.
        /// </returns>
        public int Create(<#= cbc.pascalSecureEntityName #>Dto <#= cbc.camelSecureEntityName #>Dto<#=(Secured)?", UserContextDto userContextDto":"" #>)
        {

<#= CreateExecutePreconditionsTxt.TrimEnd() #>

<#+
    string parametros = (cbc.isDerivedFromOneEntity)? cbc.MandatoryEntityBaseConstructorParamansDefinitionDTO : cbc.MandatoryConstructorParamnsDTO;       
    //if ( cbc.PathsFromFatherToClass != null)

    foreach (var item in cbc.mandatoryPropertyFromSources)
    {                
        // en este momento sustituimos en los parametros que corresponden a las entidades temp creadas anteriormente.
        // para ello primero miramos si esta entidad tiene relaciones de composición.
        //var propertyAssociationSources = Association.GetLinksToSources(item.Clase).Where(p=> !(p.TargetRolName == null || p.TargetRolName.Trim().Length == 0)); // lista de propiedades provenientes de las relaciones de origen
        
        //this.mandatoryPropertyFromSources = this.propertyAssociationSources.Where( p=> p.SourceMultiplicity==kayak.MoneyGen.Multiplicity.OneOne || p.SourceMultiplicity==kayak.MoneyGen.Multiplicity.OneMany);// subconjunto de propiedades de tipo mandatory de las anteriores, esdecir cuya multiplicidad minima es uno 
        //var mandatoryPropertyFromSources = propertyAssociationSources.Where( p=> IsMinMultiplicityOne(p.SourceMultiplicity));
     
        // si tiene relaciones de composición 
        // entonces recorremos las entidades de composición las buscamos entre los 
        // parametros que acabamos de obtener y los sustiuimos por los temp de los cuales hemos llamado a sus factorias que hemos creado anteriormente.
        // para buscar los parametros podemos utilizar el prefijo recien creado + el nombre de la entidad a sustituir.

        if (!item.Source.Name.Equals(cbc.pascalSecureEntityName))
        {                 
            System.Collections.ObjectModel.ReadOnlyCollection<kayak.MoneyGen.Association> propertyAssociationTargets = Association.GetLinksToTargets(item.Target);
            if(item.TargetRolName != null && !(item.Source is Enumeration))
            { 
#>
            I<#= T4Help.ToPascalCase(item.Source.Name) #>Repository <#= T4Help.ToCamelCase(item.Source.Name) #>Repo = ApplicationLayer.IocContainer.Resolve<I<#= T4Help.ToPascalCase(item.Source.Name) #>Repository>();
            <#= T4Help.ToPascalCase(item.Source.Name) #> <#= T4Help.ToCamelCase(item.TargetRolName) #> = <#= T4Help.ToCamelCase(item.Source.Name) #>Repo.GetById(<#= cbc.camelSecureEntityName #>Dto.<#= item.TargetRolName #>.Id);
<#+			} 
            else 
            {

            //< #= cbc.pascalSecureEntityName # > < #= cbc.camelSecureEntityName # > = < #= cbc.pascalSecureEntityName # >Factory.Create(); 

            } 
        }
    }// end foreach 
#>
            <#= cbc.pascalSecureEntityName #> <#= cbc.camelSecureEntityName #> = <#= cbc.pascalSecureEntityName #>Factory.Create
            (
                <#=cbc.MandatoryConstructorParamnsDTO #><#=(cbc.numEntityFieldsMandatory > 0 && cbc.mandatoryPropertyFromSources.Any()? ",":"") #>
<#+
    int centinel = 0;
    foreach (var item in cbc.mandatoryPropertyFromSources)
    { 
        centinel++;
#>
                <#= cbc.camelSecureEntityName #>Dto.<#= T4Help.ToPascalCase(item.TargetRolName) #><#= (centinel < cbc.mandatorySourceLinksCounter)? ",": "" #> 
<#+
    }// end foreach 
#>
            );

<#+ foreach(var property in cbc.propertyObjects.Where(c=>c.RequestUponCreation == RequestUponCreation.no)){ #>
<#+     if(property.LiveCycleAtributte.Equals(LiveCycleAtributte.Variable) /*|| property.LiveCycleAtributte.Equals(LiveCycleAtributte.Derivado)*/) {#>
<#+         if (property.AutoProperty || !property.OnlyGetProperty)     { #>
                <#= cbc.camelSecureEntityName #>.<#= T4Help.ToPascalCase(property.AtributteName) #> = <#= cbc.camelSecureEntityName #>Dto.<#= T4Help.ToPascalCase(property.AtributteName) #>; // property.AutoProperty = <#= property.AutoProperty #>; property.OnlyGetProperty = <#= property.OnlyGetProperty #>
<#+         } #>
<#+         if ( !property.AutoProperty  &&  property.OnlyGetProperty)     { #>
                <#= cbc.camelSecureEntityName #>.Set<#= T4Help.ToPascalCase(property.AtributteName) #> ( <#= cbc.camelSecureEntityName #>Dto.<#= T4Help.ToPascalCase(property.AtributteName) #> ); // property.AutoProperty = <#= property.AutoProperty #>; property.OnlyGetProperty = <#= property.OnlyGetProperty #>
<#+         } #>
<#+     } #>
<#+ } #>

<#+ if (cbc.sourceLinksCounter>0)    {#>
                // .en Getting properties that comes from parent relationships
                // .es Obtenemos las propiedades que provienen the relaciones parentales.
<#+
    // continuamos con el mapping de las propiedades de las clases padres en las asociaciones 
    foreach (var property in cbc.propertyAssociationSources)
    {
        // si no es una relación reflexiva generamos la misma pareja de métodos para los roles de target y source han de ser diferentes
        if(string.IsNullOrEmpty(property.TargetRolName)) // Validación: Comprobamos que si no existe el nombre del rol source (significa que es una relación unidireccional y por tanto solo genera propiedad en la clase destino (target) y no en la clase  origen (source) la multiplicidad minima del target ha de ser cero. 
        {
            continue;
        }
        if (!(property.Source is Enumeration))
        {
#>
            if (<#= cbc.camelSecureEntityName #>Dto.<#= T4Help.ToPascalCase(property.Source.Name) #> != null)
            {
                I<#= T4Help.ToPascalCase(property.Source.Name) #>Repository repo<#= T4Help.ToCamelCase(property.Source.Name) #> = ApplicationLayer.IocContainer.Resolve<I<#= T4Help.ToPascalCase(property.Source.Name) #>Repository>();
                var <#= T4Help.ToCamelCase(property.Source.Name) #> = repo<#= T4Help.ToCamelCase(property.Source.Name) #>.GetById(<#= cbc.camelSecureEntityName #>Dto.<#= T4Help.ToPascalCase(property.Source.Name) #>.Id);
                <#= cbc.camelSecureEntityName #>.Set<#= T4Help.ToPascalCase(property.Source.Name) #>(<#= T4Help.ToCamelCase(property.Source.Name) #>);
            }
<#+
        }
        else if( IsMinMultiplicityCero(property.SourceMultiplicity) )
        {
#>
                <#= cbc.camelSecureEntityName #>.Set<#= T4Help.ToPascalCase(property.TargetRolName) #>(<#= cbc.camelSecureEntityName #>Dto.<#= T4Help.ToPascalCase(property.TargetRolName) #>);
<#+
        }
    }// end del foreach (var property in cbc.propertyAssociationSources)
#>
<#+ } #>
            I<#= cbc.pascalSecureEntityName #>Repository repo =  ApplicationLayer.IocContainer.Resolve<I<#= cbc.pascalSecureEntityName #>Repository>();
            repo.Add(<#= cbc.camelSecureEntityName #>);
            this.Commit();

            return <#= cbc.camelSecureEntityName #>.Id; 
        }
        #endregion
<#+
        return this.GenerationEnvironment.ToString();
    } // end de TransformText
}// end template
#>
