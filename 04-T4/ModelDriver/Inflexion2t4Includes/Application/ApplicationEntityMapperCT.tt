<#+

public class ApplicationEntityMapperCT : Template
{
    // parametros de la plantilla
    public ClassBaseContext  cbc ;
    public string projectNamespace;
    public ITree<BoundedContextMetadata> Skt;
        
    // constructor de la plantilla
    public ApplicationEntityMapperCT(ClassBaseContext  classBaseContext, string nombreProjecto, ITree<BoundedContextMetadata> skt)
    {
        cbc = classBaseContext;             // contexto de la clase base a interpretar
        projectNamespace = nombreProjecto;  // nombre del proyecto para el que estamos interpretando
        Skt = skt;                          // shared kernel tree
    }

    // metodo de generación de la plantilla
    public override string TransformText()
    {
        // uso de interfaces en las propiedades y por tanto en metodos
        //por defecto se usan interfaces con nhibernate en cualquiera e sus modalidades y no se usan con entityFramework
        string I = (cbc.diagram.ORM.Contains("ibernate"))?"I":"";

        IList<string> sharedKernelUsings =  GetSharedKernelReferencesByProject(projectNamespace, Skt, cbc.diagram);
        ProjectConcepts prjCon = new ProjectConcepts(  cbc, projectNamespace, Skt);

        var cpyrigth = new CopyrightHeader(cbc.diagram, cbc.solutionInfo, cbc.entity, T4Help.getLeftStringSlice(this.ToString(), '+', -1).Substring(1));
        string cpyrigthText = cpyrigth.TransformText();
#>
<#= cpyrigthText #>
namespace <#= projectNamespace #>
{

	#region usings
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using System.Text;
	using Inflexion2;

    using <#= cbc.diagram.RootNameSpace #>.<#= prjCon.boundedContextName #>.<#= prjCon.layer #>.Dtos;
    using <#= cbc.diagram.RootNameSpace #>.<#= prjCon.boundedContextName #>.Domain;
	#endregion

    /// <summary>
	/// .en mapping class from entity to dto <see cref="<#= I #><#= cbc.secureEntityName #>Mapper"/>
    /// .es Clase pública encargada de mapear los datos de una entidad <see cref="<#= I #><#= cbc.secureEntityName #>Mapper"/>.
    /// </summary>
    public class <#= cbc.secureEntityName #>Mapper : I<#= cbc.secureEntityName #>Mapper
    {
        #region CONSTRUCTORS
        /// <summary>
		/// .en Get an instance of <see cref="<#= cbc.secureEntityName #>Mapper"/>
        /// .es Inicializa una nueva instancia de la clase <see cref="<#= cbc.secureEntityName #>Mapper"/>.
        /// </summary>
        public <#= cbc.secureEntityName #>Mapper()
        {
        } // <#= cbc.secureEntityName #>Mapper Constructor
        #endregion

        #region FUNCTIONS

          /// <summary>
		  /// .en public function mapping from entity to dto
          /// .es Función pública que mapea las entidades para devolver el
          /// correspondiente Dto.
          /// </summary>
          /// <param name="entity<#= cbc.secureEntityName #>">
          /// .es Objeto de la entidad <see cref="<#= I #><#= cbc.secureEntityName #>"/>.
          /// </param>
          /// <exception cref="System.ArgumentNullException">
		  /// .en exception when there is a null value in the parameter.
          /// .es Lanzada cuando el valor de <c>entity<#= cbc.secureEntityName #></c> es null.
          /// </exception>
          /// <returns>
		  /// .en returns an object of type <see cref="<#= cbc.secureEntityName #>Dto"/>
          /// .es Devuelve un objeto de tipo <see cref="<#= cbc.secureEntityName #>Dto"/> 
          /// con los datos mapeados.
          /// </returns>
          public <#= cbc.secureEntityName #>Dto EntityMapping(I<#= cbc.secureEntityName #> entity<#= cbc.secureEntityName #>)
          {
		    // .en checking parameters
            // .es Comprobamos el valor del argumento de entrada.
            if (entity<#= cbc.secureEntityName #> == null)
            {
				// .en Error, throwing exception.
                // .es Error, lanzamos la excepción.
                throw new System.ArgumentNullException("entity<#= cbc.secureEntityName #>");
            }
            else
            {
				// .en Answer object
                // .es Objeto de respuesta.
                <#= cbc.secureEntityName #>Dto dto<#= cbc.secureEntityName #> = new <#= cbc.secureEntityName #>Dto();
				// .en Mapping simple/main properties
                // .es Mapeamos cada propiedad.
<#+
    if(cbc.IsEntity)
    {
#>
                dto<#= cbc.secureEntityName #>.Id = entity<#= cbc.secureEntityName #>.Id;
<#+ if(cbc.LogicDelete){#>
                dto<#= cbc.secureEntityName #>.Activo = entity<#= cbc.secureEntityName #>.IsActive;
<#+ }#>
<#+
    }
#>
<#+
    foreach (var property in cbc.propertyObjects)
    {
#>
                dto<#= cbc.secureEntityName #>.<#= T4Help.ToPascalCase(property.AtributteName) #> = entity<#= cbc.secureEntityName #>.<#= T4Help.ToPascalCase(property.AtributteName) #>;
<#+
    }
#>
<#+ if (cbc.sourceLinksCounter>0)    {#>
				// .en Properties Mapping that comes from parent relationships
				// .es Mapeado de propiedades que provienen the relaciones parentales.
<#+
    // continuamos con el mapping de las propiedades de las clases padres en las asociaciones 
    foreach (var property in cbc.propertyAssociationSources)
    {
        // si no es una relación reflexiva  generamos la misma pareja de métodos para los roles de target y source han de ser diferentes
        if(string.IsNullOrEmpty(property.TargetRolName)) // Validación: Comprobamos que si no existe el nombre del rol source (significa que es una relación unidireccional y por tanto solo genera propiedad en la clase destino (target) y no en la clase  origen (source) la multiplicidad minima del target ha de ser cero. 
        {
            continue;
        }
		if (!(property.Source is Enumeration))
		{
#>
				var <#= T4Help.ToCamelCase(property.Source.Name) #>Mapper = new <#= T4Help.ToPascalCase(property.Source.Name) /*T4Help.SecureName(property.TargetRolName)*/ #>Mapper();
				dto<#= cbc.secureEntityName #>.<#= T4Help.ToPascalCase(property.Source.Name) #> = <#= T4Help.ToCamelCase(property.Source.Name) #>Mapper.EntityMapping(entity<#= cbc.secureEntityName #>.<#= T4Help.ToPascalCase(property.Source.Name) #>);
<#+
		}
		else
		{
#>
				dto<#= cbc.secureEntityName #>.<#= T4Help.ToPascalCase(property.TargetRolName) #> = entity<#= cbc.secureEntityName #>.<#= T4Help.ToPascalCase(property.TargetRolName) #>;
<#+
		}
    }// end del foreach (var property in cbc.propertyAssociationSources)
#>
<#+ } #>

				// .en return mapped object
                // .es Devolvemos el resultado.
                return dto<#= cbc.secureEntityName #>;
            }
          } // EntityMapping
        
        #endregion
    } // end class <#= cbc.secureEntityName #>Mapper
} //  <#= projectNamespace #>


<#+
        return this.GenerationEnvironment.ToString();
    } //end method override TransformText method
} // end class ApplicationEntityMapperCT
#>
