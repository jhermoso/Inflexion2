<#+
// introducimos metodos estaticos que a partir de una "ENTITY" nos devuelven información acerca de la estructura de la misma.
// como número de atributos, cualidades etc. El objetivo de estos metodos es simplificar la escritura de las t4 de generación de código.
// la utilidad de esta información en combinanción con el siguiente metodo AreAllMinMultiplicityEqual reside en el numero de constructores que tenemos que generar 
// uno vacio un segundo con los mandatory y un tercero con todos. Si todos los atributos son mandatory y coinciden las multiplicidades mínimas de las relaciones entonces solo necesitamos dos constructores el vacio y el completo.
// Este caso ocurre siempre que tenemos un tipo o un discriminante. Por lo que puede ser bastante frecuente.
// El metodo 'AreAllMandatory' nos dice si la totalidad de los atributos de la entidad son mandatory o no
// pasandole como parametro la entidad en questión.
public static bool AreAllMandatory(ClassBase entity)
    {
        bool centinela =  true; // inicializamos el centinela a true con el objeto de poder hacer un and consigo mismo en cada atibuto.
        LinkedElementCollection<Atributte> propertyObjects = ClassBaseHasAtributtes.GetAtributtes(entity); // este metodo es definido en el dsl domainRealtionship public partial class ClassBaseHasAtributtes y nos proporciona la lista de atributos

        foreach (Atributte p in propertyObjects.Where( p=> p.RequestUponCreation == RequestUponCreation.no ) )
        {
            centinela =  false;
            break;
        }

        return centinela;
    }

#>

<#+

// de forma similar a AreAllMandatory consultamos si ninguno de los atributos es mandatory
    public static bool AreAnyMandatory(ClassBase entity)
    {
        bool centinela =  true; // inicializamos el centinela a true con el objeto de poder hacer un and consigo mismo en cada atibuto.
        LinkedElementCollection<Atributte> propertyObjects = ClassBaseHasAtributtes.GetAtributtes(entity); // este metodo es definido en el dsl domainRealtionship public partial class ClassBaseHasAtributtes y nos proporciona la lista de atributos

        foreach (Atributte p in propertyObjects.Where( p=> p.RequestUponCreation != RequestUponCreation.no ) )
        {
            centinela =  false;
            break;
        }

        return centinela;
    }

#>

<#+
// El metodo 'AreAllTargetMinMultiplicityEqual' nos dice si la totalidad de las relaciones de tipo target coinciden en el tipo de multiplicidad que tienen
// pasandole como parametro la entidad en questión.
public static bool AreAllTargetMinMultiplicityEqual(ClassBase entity)
    {
        bool centinela =  true; // inicializamos el centinela a true con el objeto de poder hacer un and consigo mismo en cada atibuto.
            System.Collections.ObjectModel.ReadOnlyCollection<kayak.MoneyGen.Association> propertyAssociationTargets = Association.GetLinksToTargets(entity);
         //   System.Collections.ObjectModel.ReadOnlyCollection<kayak.MoneyGen.Association> propertyAssociationSources = Association.GetLinksToSources(entity);
        if (propertyAssociationTargets.Count()>1)
        {
            centinela = propertyAssociationTargets.Where( p=> p.SourceMultiplicity==kayak.MoneyGen.Multiplicity.CeroOne | p.SourceMultiplicity==kayak.MoneyGen.Multiplicity.CeroMany).Count().Equals(propertyAssociationTargets.Count());
            centinela = centinela & propertyAssociationTargets.Where( p=> p.SourceMultiplicity==kayak.MoneyGen.Multiplicity.OneOne | p.SourceMultiplicity==kayak.MoneyGen.Multiplicity.OneMany).Count().Equals(propertyAssociationTargets.Count());
        }
        return centinela;
    }

#>

<#+
// el metodo 'AreAllSourceMinMultiplicityEqual' nos dice si la totalidad de las relaciones de tipo source coinciden en el tipo de multiplicidad que tienen
// pasandole como parametro la entidad en questión.
public static bool AreAllSourceMinMultiplicityEqual(ClassBase entity)
    {
        bool centinela =  true; // inicializamos el centinela a true con el objeto de poder hacer un and consigo mismo en cada atibuto.
           // System.Collections.ObjectModel.ReadOnlyCollection<kayak.MoneyGen.Association> propertyAssociationTargets = Association.GetLinksToTargets(entity);
            System.Collections.ObjectModel.ReadOnlyCollection<kayak.MoneyGen.Association> propertyAssociationSources = Association.GetLinksToSources(entity);
        if (propertyAssociationSources.Count()>1)
        {
            centinela = propertyAssociationSources.Where( p=> p.SourceMultiplicity==kayak.MoneyGen.Multiplicity.CeroOne | p.SourceMultiplicity==kayak.MoneyGen.Multiplicity.CeroMany).Count().Equals(propertyAssociationSources.Count());
            centinela = centinela & propertyAssociationSources.Where( p=> p.SourceMultiplicity==kayak.MoneyGen.Multiplicity.OneOne | p.SourceMultiplicity==kayak.MoneyGen.Multiplicity.OneMany).Count().Equals(propertyAssociationSources.Count());
        }
        return centinela;
    }

#>

<#+

public static bool HasChildren(ClassBase entity)
    {
        if ( Inherintance.GetLinksToSubClasses( entity ).Any())
        {
            return true;
        }
        
        
        if (kayak.MoneyGen.ClassBaseHasNestedClassBases.GetLinksToTargetClassBases( entity ).Any())
        {
            return true;
        }
        else
        {
            return false;
        }
        
    }// end HasChildren

#>

<#+

public static bool entityHasAttributesOrAssociations(ClassBase entity)
    {
        bool centinela = ClassBaseHasAtributtes.GetAtributtes(entity).Any() ; // Count() > 0
        centinela = centinela | Association.GetLinksToSources(entity).Any() ; // Count() > 0
        centinela = centinela | Association.GetLinksToTargets(entity).Any() ; // Count() > 0
        return centinela;
    }

#>

<#+

/// <sumary> 
/// nos indica si la entidad que se le pasa como parametro es target de una unica relación de composición.
/// o si es destino de varias relaciones de composición de una misma entidad.
/// nos devuelve la combinación de posibilidades que esta entidad cumple mediante flags binarios.
/// </sumary>
public static KindComponented WhatTypeComponented(ClassBase entity)
    {
        bool centinela = true; // valor lógico para ayudar a evaluar cada una de las condiciones buscadas en cada caso.

        KindComponented typeComponent = KindComponented.any;
        System.Collections.ObjectModel.ReadOnlyCollection<kayak.MoneyGen.Composition>  compositionTargetLinks = CompositionBase.GetLinksToCompositionTargets (  entity );
        System.Collections.ObjectModel.ReadOnlyCollection<kayak.MoneyGen.Composition>  compositionSourceLinks = CompositionBase.GetLinksToCompositionSources (  entity );
        // caso 0 no es tarjet de ninguna relación de composición.
        //if (okDebug)  Debug.Write("                      Los contadores de relaciones para "); Debug.Write(entity.Name); Debug.Write(" es :"); Debug.Write (compositionSourceLinks.Count);Debug.Write ("/");Debug.WriteLine (compositionTargetLinks.Count);
        if (compositionSourceLinks.Count == 0 & compositionTargetLinks.Count == 0)
            {
                return typeComponent;
            }

        if ( compositionTargetLinks.Count >= 1 & compositionSourceLinks.Count == 0 )
        { 
            typeComponent |= KindComponented.isOneFather;
            return typeComponent;
        }

        if (/*compositionTargetLinks.Count == 0 &*/ compositionSourceLinks.Count == 1 )
        { 
            foreach (var linkC in  compositionSourceLinks )
            {
                // comparamos la entidad target y source de cada relación de composición consigo misma.
                //if (okDebug)  Debug.Write("                      Comparamos la entidad PARA VER SI ES REFLEXIVA '"); Debug.Write (entity.Name); Debug.Write ("' con source ='");Debug.Write(linkC.Source.Name);Debug.WriteLine ("'");
                if (!(linkC.Source.Equals(entity)))
                { 
                   typeComponent |= KindComponented.isOneChild;
                }
                else
                {
                    typeComponent |= KindComponented.partialReflexive;
                    string mensaje = "La entidad de nombre '"+entity.Name+"' Se ha modelado con composición reflexiva. Las relaciones reflexivas han de ser de agregación no pueden ser de composición.";
                    throw new System.ApplicationException(mensaje);
                }
            }
            return typeComponent;
        }

        //if (compositionSourceLinks.Count > 1 /* & compositionTargetLinks.Count > 0 */)
        //{
            //typeComponent |= KindComponented.isOneFather;
           ///* typeComponent |= KindComponented.isOneChild; */
        //}
            
        if (compositionSourceLinks.Count >1)
        {
            int i =0;
            kayak.MoneyGen.Composition linkAnterior = null;
            foreach (var linkC in  compositionSourceLinks )
            {
                if (i!=0)
                {
                    // caso : es destino de varias relaciones de composición con una misma entidad.
                    if (linkAnterior.Target.Equals(linkC.Target) )
                    {centinela = centinela & true;}
                    else
                    {centinela = centinela & false;}
                    linkAnterior = linkC;
                }
                else
                {
                    linkAnterior = linkC;
                }
            }
            if (centinela & compositionSourceLinks.Count >1)
            {
                typeComponent |= KindComponented.allAreOneFather ; 
            }
        } 

        // tanto si solo tiene una relación como si tiene varias seguimos investigando que tipo tienen
        // caso 2 ¿es solo composición reflexiva?
 
        bool tieneAlmenosUnaReflexiva = false;
        bool tieneAlmenosUnaXor = false;
            foreach (var linkC in compositionSourceLinks )
            {
                // comparamos la entidad target y source de cada relación de composición consigo misma.
               // Debug.Write("                      Comparamos la entidad '"); Debug.Write (entity.Name); Debug.Write ("' con target ='");Debug.Write (linkC.Target.Name);Debug.Write ("' con source ='");Debug.Write(linkC.Source.Name);Debug.WriteLine ("'");
                if (linkC.Target.Equals(entity) & linkC.Source.Equals(entity))
                { 
                    tieneAlmenosUnaReflexiva = true;
                    string mensaje = "La entidad de nombre '"+entity.Name+"' Se ha modelado con composición reflexiva. Las relaciones reflexivas han de ser de agregación no pueden ser de composición.";
                    throw new System.ApplicationException(mensaje);
                }
 
                if (!string.IsNullOrEmpty(linkC.XorRelation)) // si no esta vacio
                {
                    tieneAlmenosUnaXor = true;
                }                  // entoces tiene al menos una relación xor
            }

        if (tieneAlmenosUnaReflexiva)
        {
            typeComponent |= KindComponented.partialReflexive ; 
        }
            if (tieneAlmenosUnaXor)
        {
            typeComponent |= KindComponented.xor ; // TODO : aqui habria que ampliar para comprobar que el nuemro de relaciones xor es superior a 1 ¿tiene sentido relaciones xor entre agragaciones y composiciones?
        }
//
// caso 4 es composición xor de una o varias entidades
        return typeComponent;
    }

#>

<#+
    // este metodo solo se deberia llamar si se ha comprobado previamente que solo hay una relación de composición o todas tienen el mismo padre.
    // su objeto es proporcionarnos el path de carpetas anidadas para la composición.
    // también tiene encuenta que una de las entidades en las que se va a anidar este a su vez anidada
    // por tratarse de una subclase derivada de una superclase
public static string  GetFatherCompouserFolder(ClassBase entity)
    {
        // TODO: comprobar antes que es KindComponented.isOneChild o KindComponented.allAreOneFather
        string fatherFolder = null;
        ClassBase entityFather =null;
        KindComponented kc = KindComponented.any;
        System.Collections.ObjectModel.ReadOnlyCollection<kayak.MoneyGen.Composition>  compositionSourceLinks = CompositionBase.GetLinksToCompositionSources (  entity );
        
        foreach (var link in compositionSourceLinks )
        {
            if(!(link.Source is Entity)) continue; // solo pueden ser aggregate roots las entida
            entityFather = link.Source;
            fatherFolder = entityFather.Name ; 
            kc  = WhatTypeComponented( entityFather );
            if (IsDerived(entityFather))
            {
               fatherFolder = GetSuperFolders(entityFather) + System.IO.Path.DirectorySeparatorChar + fatherFolder;
            }
            else if (  kc.Equals(KindComponented.isOneChild) | kc.Equals(KindComponented.allAreOneFather )  )
            {
                fatherFolder =GetFatherCompouserFolder(entityFather)+ System.IO.Path.DirectorySeparatorChar + fatherFolder  ;
            }
        }
        return fatherFolder;
    }

#>

<#+
    // enumerado de flags para catalogar los diferentes tipos de situación en los que se puede encontrar una relacion de composición.
        ////SelectionCriteriaAttributesFlag values
        //// 0 = any
        //// 1 = all normal attributes// not include index, not include object value, not 
        //// 2 = only mandatory
        //// 4 = only identifications
        //// 8 = only searcheables
        //// 16 = only Indexeds
        //// 32 = only HeadGroup
        //// 64 = filters
        //// 128 = only Optional
        //// 256 = only collections
        //// 512 = only nullables
        //// 1024 = only value type
        //// 2048 = only reference type
        //// 4096 = target this enum is combined with some of the assocition type.
        //// 8192 = Association
        //// 16384 = Aggregations
        //// 32768 = Compositions
    [global::System.Flags]
    public enum SelectionCriteriaAttributes : int
    {
        /// <sumary> No seleccionamos ningun los atributos <sumary/>
        Any                 = 0,

        /// <sumary> Seleccionamos todos los atributos <sumary/>
        AllNormal           = 1,

        /// <sumary> Selecionamos los atributos marcados como mandatory <sumary/>
        Mandatory           = 2,

        /// <sumary> Seleccionamos los atributos marcados como que pueden identificar a la entidad <sumary/>
        Identifications     = 4,

        /// <sumary> Seleccionamos los atributos marcados como atributos por los que realizar busquedas <sumary/>
        Searcheables        = 8,

        /// <sumary> Seleccionamos los atributos marcados como que debieran estar indexados <sumary/>
        Indexeds            = 16,

        /// <sumary> Seleccionamos los atributos marcados como que agrupan a otros atributos <sumary/>
        HeadGroup           = 32,

        /// <sumary> Seleccionamos los atributos marcados como citerios de filtrado <sumary/>
        Filters             = 64,

        /// <sumary> Seleccionamos los atributos que no son mandatory u opcionales <sumary/>
        Optional            = 128,

        /// <sumary> Seleccionamos los atributos que son  de tipo colección, mandatory u opcionales <sumary/>
        Collections         = 256,

        /// <sumary> Seleccionamos los atributos que son nullables marcados con ?<sumary/>
        Nullables           = 512,

        /// <sumary> Seleccionamos los atributos que son de tipo valor <sumary/>
        ValueTypes          = 1024,

        /// <sumary> Seleccionamos los atributos que son de tipo referencia <sumary/>
        ReferenceTypes      = 2048,

        /// <sumary> en combinación con las relaciones de asociación o agragación o composición elige los roles de tipo target <sumary/>
        Targets             = 4096,

        /// <sumary> en combinación con las relaciones de asociación o agragación o composición elige los roles de tipo source <sumary/>
        Sources             = 8192,

        /// <sumary> Selecionamos los atributos derivados de las relacions de asociación <sumary/>
        Associations        = 16384,

        /// <sumary> Selecionamos los atributos derivados de las relacions de agregación <sumary/>
        Aggregations        = 32768,

        /// <sumary> Selecionamos los atributos derivados de las relacions de composición <sumary/>
        Compositions        = 65536

    }// end enum SelectionCriteriaAttributes  

#>

<#+

    // enumerado de flags para indicar las diferentes combinaciones de criterios de selección de la lista de atributos de una entidad.
    [global::System.Flags]
    public enum KindComponented : int
    {
        /// <sumary> caso 0 no es tarjet de ninguna relación de composición. <sumary/>
        any                 = 0,

        /// <sumary> caso es Padre de una o varias relaciones de composición de una misma entidad. <sumary/>
        isOneFather         = 1,

        /// <sumary> caso es hijo de una o varias relaciones de composición de una misma entidad. <sumary/>
        isOneChild          = 2,
        /// <sumary> caso tiene alguna composición reflexiva <sumary/>
        partialReflexive    = 4,

        /// <sumary> caso tiene varias pero todas contra el mismo padre. Por ejemplo entre realtionship y rol <sumary/>
        allAreOneFather     = 8,

        /// <sumary> caso 8 es composición xor de una o varias entidades <sumary/>
        xor                 = 16  //Next values could be  0x20, 0x40
    }

#>

<#+

    ///<sumary> este método nos permite obtener la lista de parametros a incluir en un constructor  para la entidad que se pasa como parametro
    ///         los parametros son la entidad , el criterio de selección y el limite en caracteres a a partir del cual la lista pasa de escribirse en una linea
    ///         para pasar a ser escrita en multilinea.
    /// entity es la entidad
    /// bool autonumerico informa sobre si el modelo es con guid o con autonumerico
    /// Selection criteria attributes es sobre las combinaciones de selección de los atributos
    /// int limitesalto es apartir de cuantos caracteres escribimos la cadena de parametros mediante saltos de line o de forma continua
    /// bool incluir tipo es si elaboramos la lista incluyendo el tipo de las propiedades
    /// int spaceIndent es laindentación de espacios que se añade cuando se realiza se escriben los parameros con salto de linea.
    /// bool incluir los valores por defecto consiste en incluir las expresiones que incializan los valores por defecto
    /// inlcuir el id indica si incluimos el campo de identificación o no
    /// bool pascalCase indica si queremos las propiedades capitalizadas o no
    /// prefijo y sufijo son cadenas anteriores y posteriores que se añaden a cada uno de los campos
    /// ObjectValueSpreadOut indicamos si incluimos objetos valor
    /// useInterface indicamos si usamos la interface de las propiedades provenientes de relaciones o no.
    ///<sumary/>
    public static string GetConstructorParametersString(
                                                        ClassBase entity, 
                                                        bool autonumerico ,
                                                        SelectionCriteriaAttributes flag, 
                                                        int limiteSalto, 
                                                        bool incluirTipo, 
                                                        int spaceIndent, 
                                                        bool incluirDefaultValues, 
                                                        bool incluirId, 
                                                        bool incluirTargetAssociations, 
                                                        bool incluirSourceAssociations, 
                                                        bool    pascalCase=false, 
                                                        string  prefijo=null, 
                                                        string  sufijo=null,
                                                        bool    ObjectValueSpreadOut = true,
                                                        bool    useInterface = true
                                                       )
    {
        //SelectionCriteriaAttributesFlag values
        // 0 = any
        // 1 = all normal attributes
        // 2 = only mandatory
        // 4 = only identifications
        // 8 = only searcheables
        // 16 = only Indexeds
        // 32 = only HeadGroup
        // 64 = filters
        // 128 = only Optional
        // 128 = only collections
        // 256 = only nullables
        // 512 = only value type
        // 1024 = only reference type
        // 2048 = target this enum is combined with some of the assocition type.
        // 4096 = Association
        // 8192 = Aggregations
        // 16384 = Compositions

        bool okDebug = false;//entity.Name.Equals("Empresa")|| entity.Name.Equals("Socio");//entity.Name.Equals("Parrilla") & incluirTipo;
        if (okDebug) 
        {
        Debug.WriteLine(string.Format("Entramos en GetConstructorParametersString con '{0}' con los siguientes parametros",entity.Name));

         Debug.WriteLine(string.Format("                 autonumerico = '{0}'",autonumerico));
         Debug.WriteLine(string.Format("                         flag = '{0}'",flag.ToString()));
         Debug.WriteLine(string.Format("                  limiteSalto = '{0}'",limiteSalto));
         Debug.WriteLine(string.Format("                  incluirTipo = '{0}'",incluirTipo));
         Debug.WriteLine(string.Format("                  spaceIndent = '{0}'",spaceIndent));
         Debug.WriteLine(string.Format("         incluirDefaultValues = '{0}'",incluirDefaultValues));
         Debug.WriteLine(string.Format("                  incluirId   = '{0}'<=",incluirId));
         Debug.WriteLine(string.Format("    incluirTargetAssociations = '{0}'",incluirTargetAssociations));
         Debug.WriteLine(string.Format("    incluirSourceAssociations = '{0}'",incluirSourceAssociations));
         Debug.WriteLine(string.Format("                   pascalCase = '{0}'",pascalCase));
         Debug.WriteLine(string.Format("                      prefijo = '{0}'",prefijo));
         Debug.WriteLine(string.Format("                       sufijo = '{0}'",sufijo));

         }

        StringBuilder ChainParams = new StringBuilder();
        StringBuilder TemporalChainParams = new StringBuilder();
        string TemporalStringParamams;

        LinkedElementCollection<Atributte> propertyObjects = ClassBaseHasAtributtes.GetAtributtes(entity); // este método es definido en el dsl domainRealtionship public partial class ClassBaseHasAtributtes 
        System.Collections.Generic.IEnumerable<kayak.MoneyGen.Association> propertyAssociationTargets = Association.GetLinksToTargets(entity).Where(p=> !(p.SourceRolName == null || p.SourceRolName.Length == 0));// lista de propiedades obtenidas de las relaciones de destino
        System.Collections.Generic.IEnumerable<kayak.MoneyGen.Association> propertyAssociationSources = Association.GetLinksToSources(entity).Where(p=> !(p.TargetRolName == null || p.TargetRolName.Length == 0));// lista de propiedades provenientes de las relaciones de origen

        var mandatoryPropertyFromSources = propertyAssociationSources.Where( p=> p.SourceMultiplicity==kayak.MoneyGen.Multiplicity.OneOne || p.SourceMultiplicity==kayak.MoneyGen.Multiplicity.OneMany);// subconjunto de propiedades de tipo mandatory de las anteriores es decri cuya multiplicidad minima es uno 
        var mandatoryPropertyFromTargets = propertyAssociationTargets.Where( p=> p.TargetMultiplicity==kayak.MoneyGen.Multiplicity.OneOne || p.TargetMultiplicity==kayak.MoneyGen.Multiplicity.OneMany); // subconjunto de propiedades de tipo mandatory de las anteriores es decri cuya multiplicidad minima es uno

        //propertyObjects = propertyObjects.Where();

        int AtributesCounter= propertyObjects.Count();
        int sourceLinksCounter= propertyAssociationSources.Count();
        int targetLinksCounter= propertyAssociationTargets.Count();
        int mandatorySourceLinksCounter= mandatoryPropertyFromSources.Count();
        int mandatoryTargetLinksCounter= mandatoryPropertyFromTargets.Count();
        var selectedPropertys = propertyObjects.Where(c => true);
        int selectedPropertysCounter = selectedPropertys.Count();

        int commaCounter = 0; // contador de propiedades para establecer que la última propiedad no tenga una coma despues.se aplica a los atributos normales que se hacen en dos tandas 1ª tanda sin valores por defecto 2ª tanda valores con defecto
        //int auxCommacounter =0; // contador de propiedades derivdas de relaciones se utiliza dos vexes para las source y para las target.
        int defaultValuePropertyCounter = 0; // contador de las propiedades que tienen un valor por defecto.
        //if(flag == SelectionCriteriaAttributes.AllNormal) // comentado por ser el valor por defecto
        //{
            //selectedPropertys = propertyObjects;
        //}
        //else
        if ((flag & SelectionCriteriaAttributes.Mandatory ) == SelectionCriteriaAttributes.Mandatory )
        {
            selectedPropertys = propertyObjects.Where(att => att.RequestUponCreation == RequestUponCreation.yes);
        }

        if (flag == SelectionCriteriaAttributes.Any )
        {
            selectedPropertys = propertyObjects.Where(c => false);
        }

        //if(!IsDerived(entity)) // si la entidad no esta derivada de otra derivara entonces de iauditable entity o de entity por tanto debemos incluir su id.
        //{
        if (incluirId && entity is Entity) // en función de la opción incluimos el id o no
        {
            if(incluirTipo) ChainParams.Append((autonumerico)  ? "int " : "Guid "); // si hay que incluir el tipo
            if(pascalCase)
            ChainParams.Append(prefijo+"Id"+entity.Name+sufijo); // el nombre que damos en el constructor es id + el nombre de la entidad
                else
            ChainParams.Append(prefijo+"id"+entity.Name+sufijo); // el nombre que damos en el constructor es id + el nombre de la entidad
        
            //if( selectedPropertysCounter >0 | mandatorySourceLinksCounter>0 | mandatoryTargetLinksCounter>0) ChainParams.Append(", "); // si la entidad no tiene propiedades no escribimos la comma despues del id.
        }
         if (okDebug) {Debug.WriteLine(string.Format("paso 1 incluirID en ChainParams = '{0}'",ChainParams));}
        //}// si por el contrario la entidad deriva de otra entonces llamaremos al constructor base que lo incluira.

        // debido a que es necesario colocar en ultimo lugar los parametros que tienen un valor por defecto
        // realizamos la construcción de la cadena de parametros en dos tandas
        //en la primera añadimos los parametros sin valor por defecto 
        // en la segunda los parametros que provienen de las relaciones source y que son mandatory por tener multiplicidad minima 1
        // en la tercera los parametros que provienen de las relaciones target y que tienen un mandatory por tener multiplicidad minima 1
        //  en la ultima los parametros que tienen valores por defecto.
         if (okDebug) {Debug.WriteLine(string.Format("el numero de selectedPropertys es {0}",selectedPropertysCounter));}
         TemporalChainParams.Clear();
        foreach (var property in selectedPropertys)
        {
            commaCounter++;
            if(String.IsNullOrEmpty(property.DefaultValue.Trim()) )  //Si no tiene un valor por defecto.
            {
                if (incluirTipo)
                {

                    TemporalChainParams.Append(property.AtributteType.ToString());
                    if (property.IsNullable ) // si la propiedad esta marcada como nullable 
                    { 
                        if (T4Help.IsValueType(property.AtributteType))// comprobamos que sea de tipo valor 
                        {                                       // pues no podemos marcar como nullable un tipo por referencia.
                            TemporalChainParams.Append("?");
                        }
                    }
                    TemporalChainParams.Append(" ");
                }
                if (T4Help.AreAllCapitals(property.AtributteName)) //si todos los caracteres del nombre son mayusculas lo pasamos a minusculas
                    if(pascalCase)
                        TemporalChainParams.Append(prefijo+(property.AtributteName)+sufijo);
                    else
                        TemporalChainParams.Append(prefijo+(property.AtributteName.ToLower().ToString())+sufijo);
                else
                    if(pascalCase)
                        TemporalChainParams.Append(prefijo+T4Help.ToPascalCase(property.AtributteName.ToString())+sufijo); // si por el contrario solo estan capitalizados lo pasamos a camel case.
                    else
                        TemporalChainParams.Append(prefijo+T4Help.ToCamelCase(property.AtributteName.ToString())+sufijo); // si por el contrario solo estan capitalizados lo pasamos a camel case.

                TemporalChainParams.Append( ", " );// añadimos una coma y un espacio posterior

            }
            else
            {
                defaultValuePropertyCounter++; // en caso de que tenga un valor por defecto
            }
        } // acaba la primera tanda de atributos que no tienen valores default

        // acumulamos el resultado de forma segura
        TemporalStringParamams = T4Help.joinParams(ChainParams, TemporalChainParams);
        ChainParams.Clear().Append(TemporalStringParamams);
        TemporalChainParams.Clear();

         if (okDebug) {Debug.WriteLine(string.Format("paso 2 incluir selectedPropertys en ChainParams = '{0}'",ChainParams));}

        //***************
        // comienza la tanda de atributos que provienen de las relaciones padre: source
        if (incluirSourceAssociations & mandatorySourceLinksCounter>0)
        {
            string parametesFromSourceObjValue =null;
            foreach (var property in mandatoryPropertyFromSources)
            {
                // si desplegamos los objetos valor en sus campos correspondientes solo seleccionaremos aquellos que son mandatory.

                if (property.Source is ObjectValue && ObjectValueSpreadOut)
                {
                string calculatedPrefix = prefijo+((pascalCase)?T4Help.ToPascalCase(property.TargetRolName):T4Help.ToCamelCase(property.TargetRolName));
                parametesFromSourceObjValue = GetConstructorParametersString(
                                                         property.Source, 
                                                         autonumerico ,
                                                         flag, 
                                                         limiteSalto, 
                                                         incluirTipo, 
                                                         spaceIndent, 
                                                         incluirDefaultValues, 
                                                         incluirId, 
                                                         false, /*incluirTargetAssociations, */
                                                         false, /*incluirSourceAssociations */
                                                         pascalCase, 
                                                         calculatedPrefix, /*añadimos al prefijo el nombre de la clase para distinguir los atributos de entidades compuestas que tienen el mismo nombre*/
                                                         sufijo
                                                       );

                    TemporalChainParams.Append(parametesFromSourceObjValue); // añadimos los campos del objeto valor que son mandatory.
                    TemporalChainParams.Append(" ");
                }
                    else
                {
                    if (incluirTipo)
                    {
                        if (!(property.Source is Enumeration) && useInterface)
                        {
                            TemporalChainParams.Append("I");  // Por defecto cuando incluimos un tipo si este se deriva de una entidad u objeto valor relacionado hacemos referencia a su interface. TODO: CONVERTIR ESTO EN UNA OPCION PARAMETRIZADA
                        }

                        TemporalChainParams.Append(property.Source.Name); // El tipo es el nombre de la entidad target
                        TemporalChainParams.Append(" ");
                    
                    }
                    if(T4Help.AreAllCapitals(property.TargetRolName)) //si todos los caracteres del nombre son mayusculas lo pasamos a minusculas
                        if(pascalCase)
                            TemporalChainParams.Append(prefijo+(property.TargetRolName)+sufijo);
                        else
                            TemporalChainParams.Append(prefijo+(property.TargetRolName.ToLower().ToString())+sufijo);
                    else
                        if(pascalCase)
                        TemporalChainParams.Append(prefijo+T4Help.ToPascalCase(property.TargetRolName.ToString())+sufijo); // si por el contrario solo estan capitalizados lo pasamos a camel case.
                    else
                        TemporalChainParams.Append(prefijo+T4Help.ToCamelCase(property.TargetRolName.ToString())+sufijo); // si por el contrario solo estan capitalizados lo pasamos a camel case.
                }
                TemporalChainParams.Append( ", " );// añadimos una coma y un espacio posterior
            }
        }
        // acumulamos el resultado de forma segura
        TemporalStringParamams = T4Help.joinParams(ChainParams, TemporalChainParams);
        ChainParams.Clear().Append(TemporalStringParamams);
        TemporalChainParams.Clear();
         if (okDebug) {Debug.WriteLine(string.Format("paso 3 incluir source associations en ChainParams = '{0}'",ChainParams));}

        // comienza la tanda de atributos que provienen de las relaciones hijo: target 
        // tener encuanta que no se ha de pasar una colleción sino solo una instancia
        if (incluirTargetAssociations & mandatoryTargetLinksCounter > 0)
        {
            foreach (var property in mandatoryPropertyFromTargets)
            {
                    if (true) //(!IsMinMultiplicityOne(property.TargetMultiplicity)) // CORRECCION : LOS CONSTRUCTORES DE COMPOSICIÓN SE HACEN CON LISTAS NO CON CAMPOS.
                    {
                      //TemporalChainParams.Append(" /*T*/ ");
                        if (incluirTipo) /**/
                        {
                            TemporalChainParams.Append(
                                                            GetTypeFromAssociationLink(
                                                                                        property,                                                    /* kayak.MoneyGen.Association */
                                                                                        true    ,                                                    /* bool versionInterface, */
                                                                                        (autonumerico)  ? "int " : "Guid ",                          /* string idtype , */
                                                                                        (string.IsNullOrEmpty(sufijo))? false: sufijo.Equals("Dto")  /* bool dtoversion = false */
                                                                                      )
                                                      ).Append(" ");
                        }

                        if(T4Help.AreAllCapitals(property.SourceRolName)) //si todos los caracteres del nombre son mayusculas lo pasamos a minusculas
                            if(pascalCase)
                                TemporalChainParams.Append(prefijo+(property.SourceRolName)+sufijo);
                            else
                                TemporalChainParams.Append(prefijo+(property.SourceRolName.ToLower().ToString())+sufijo);
                        else
                            if(pascalCase)
                                TemporalChainParams.Append(prefijo+T4Help.ToPascalCase(property.SourceRolName.ToString())+sufijo); // si por el contrario solo estan capitalizados lo pasamos a camel case.
                            else
                                TemporalChainParams.Append(prefijo+T4Help.ToCamelCase(property.SourceRolName.ToString())+sufijo); // si por el contrario solo estan capitalizados lo pasamos a camel case.

                        TemporalChainParams.Append( ", " );// añadimos una coma y un espacio posterior
                    }
                else
                {
                // procesamos una multiplicidad de relación en la que el source y el target tienen una multiplicidad minima de one 
                // Ejemplo: Empresa-socio donde una empresa no puede exisistir sin almenos un socio.
                // en este caso ademas de pasar la collección vamos a pasar los campos de la entidad componente.
                // Para ello obtenemos el string de parametros en las mismas condiciones de parametros de la llamada y acontinuación
                //  quitamos las referencias a la entidad padre. Posteriormente el constructor debera discernir que le viene una lista nula 
                // o unos campos nulos para determinar que hacer.
                string calculatedPrefix = ((pascalCase)? T4Help.ToPascalCase(property.Target.Name) : T4Help.ToCamelCase(property.Target.Name))+prefijo;
                string parametesFromTarget = GetConstructorParametersString(
                                                         property.Target, 
                                                         autonumerico ,
                                                         flag, 
                                                         limiteSalto, 
                                                         incluirTipo, 
                                                         spaceIndent, 
                                                         incluirDefaultValues, 
                                                         incluirId, 
                                                         incluirTargetAssociations, 
                                                         false, /*incluirSourceAssociations */
                                                         pascalCase, 
                                                         calculatedPrefix, /*añadimos al prefijo el nombre de la clase para distinguir los atributos de entidades compuestas que tienen el mismo nombre*/
                                                         sufijo
                                                       );
                if (okDebug) {Debug.WriteLine(string.Format("composición fuerte. Los parametros de la entidad compuesta son = '{0}'",parametesFromTarget));}
                string token = T4Help.joinParams(TemporalChainParams.ToString(), parametesFromTarget);
                if (okDebug) {Debug.WriteLine(string.Format("composición fuerte. y el resultado final es = '{0}'",token));}
                TemporalChainParams.Clear().Append(token);
                }// end if (IsMinMultiplicityCero(property.TargetMultiplicity))
            }
        }
        // acumulamos el resultado de forma segura
        TemporalStringParamams = T4Help.joinParams(ChainParams, TemporalChainParams);
        ChainParams.Clear().Append(TemporalStringParamams);
        TemporalChainParams.Clear();

if (okDebug) {Debug.WriteLine(string.Format("paso 4 incluir target associations en ChainParams = '{0}'",ChainParams));}

        // comienza la ultima tanda de atributos provenientes de la propia entidad que no tienen valores default
        commaCounter = 0;
        foreach (var property in selectedPropertys)
        {

            if(!String.IsNullOrEmpty(property.DefaultValue.Trim()) )
            {
                if (incluirTipo)
                {
                    TemporalChainParams.Append(property.AtributteType.ToString());
                    if (property.IsNullable ) // si la propiedad esta marcada como nullable 
                    {
                        if (  T4Help.IsValueType(property.AtributteType))// comprobamos que sea de tipo valor 
                        {                                       // pues no podemos marcar como nulable un tipo por referencia.
                                TemporalChainParams.Append("?");
                        }
                    }
                    TemporalChainParams.Append(" ");
                }
                if(T4Help.AreAllCapitals(property.AtributteName)) //si todos los caracteres del nombre son mayusculas lo pasamos a minusculas
                    if(pascalCase)
                        TemporalChainParams.Append(prefijo+(property.AtributteName)+sufijo);
                    else
                        TemporalChainParams.Append(prefijo+(property.AtributteName.ToLower().ToString())+sufijo);
                else
                    if(pascalCase)
                        TemporalChainParams.Append(prefijo+T4Help.ToPascalCase(property.AtributteName.ToString())+sufijo); // si por el contrario solo estan capitalizados lo pasamos a pascal case.
                    else
                        TemporalChainParams.Append(prefijo+T4Help.ToCamelCase(property.AtributteName.ToString())+sufijo); // si por el contrario solo estan capitalizados lo pasamos a pascal case.
                if (incluirTipo & incluirDefaultValues) // solo si es necesario incluir el tipo, tenemos que incluir tambien el valor por defecto dado que estamos definiendo los parametros del constructor.
                {
                    TemporalChainParams.Append( " = " );
                    TemporalChainParams.Append( property.DefaultValue );
                }

                TemporalChainParams.Append( ", " );// añadimos una coma y un espacio posterior
            }
        }

        TemporalStringParamams = T4Help.joinParams(ChainParams, TemporalChainParams);
        ChainParams.Clear().Append(TemporalStringParamams);
        TemporalChainParams.Clear();

if (okDebug) {Debug.WriteLine(string.Format("TemporalChainParamss = '{0}'",TemporalChainParams));}
if (okDebug) {Debug.WriteLine(string.Format("paso 5 incluir default values en ChainParams = '{0}'",ChainParams));}

        if(ChainParams.Length>limiteSalto)
        {
          
          string temp = System.Text.RegularExpressions.Regex.Replace(ChainParams.ToString(), ", ",",\n"); // buscamos una coma seguida de un espacio y lo substituimos por una coma seguido de un salto de linea + los espacios de indentación
            temp = System.Text.RegularExpressions.Regex.Replace(temp.ToString(), ",\n",",\n"+  T4Help.Indent(spaceIndent));
            ChainParams.Clear();
            ChainParams.Append("\r\n");
            ChainParams.Append( T4Help.Indent(spaceIndent)); // proporcionamos una indentación de la primera linea para obligar a que exista un salto de linea despues del parantesis del constructor
            ChainParams.Append(temp);
        }
if (okDebug) {Debug.WriteLine(string.Format("paso 6 incluir saltos en ChainParams = '{0}'",ChainParams));}
        return ChainParams.ToString();
    }
#>

<#+
 public static string GetConstructorParametersStringSuperClasess(ClassBase entity, bool autonumerico ,SelectionCriteriaAttributes flag, int limiteSalto, bool incluirTipo, int spaceIndent, bool incluirDefaultValues, bool incluirId, bool incluirTargetAssociations, bool incluirSourceAssociations, bool pascalCase=false, string prefijo=null, string sufijo=null)
    {
        ClassBase e;
        string derivedParams=null;
        string coma;
        string temporal;
        if (IsDerived(entity)  )
        {
            e = entity;
            derivedParams = "";
            while (IsDerived(e))
            {
                e = GetSuperEntity(e);
                // invocamos de forma recursiva la obtención de parametros subiendo por la taxonomia de herencia. El unico paramentro que cambia es la entidad que se pasa la super y el id que en las superclases no se solicita.
                temporal =  GetConstructorParametersString( e, autonumerico , flag,  limiteSalto,  incluirTipo,  spaceIndent,  incluirDefaultValues, false,  incluirTargetAssociations,  incluirSourceAssociations,  pascalCase,  prefijo,  sufijo );
                if (!String.IsNullOrEmpty(temporal) & !String.IsNullOrEmpty(derivedParams))
                    {coma = ", ";}
                else
                    {coma = "";}
                derivedParams = String.Concat(derivedParams ,coma, temporal);
            }
        }
        return derivedParams;

        // con respecto a la coma se podria comprobar si la entidad que se pasa como parametro tiene o no atributos pero 
    }

#>

<#+

    public static string GetAttributesParametersString(ClassBase entity, int SelectionCriteriaAttributes, bool fromAssociations , int limiteSalto)
    {
        string ChainParams = null;
        LinkedElementCollection<Atributte> propertyObjects = ClassBaseHasAtributtes.GetAtributtes(entity); // este metodo es definido en el dsl domainRealtionship public partial class ClassBaseHasAtributtes 
        System.Collections.ObjectModel.ReadOnlyCollection<kayak.MoneyGen.Association> propertyAssociationTargets = Association.GetLinksToTargets(entity);
        System.Collections.ObjectModel.ReadOnlyCollection<kayak.MoneyGen.Association> propertyAssociationSources = Association.GetLinksToSources(entity);


        return ChainParams;
    }

#>

<#+
            /// <summary>
        /// Obtenemos la lista de las ClassBase que derivan recursivamente de alguna ClassBase y que 
        /// corresponden a las formas anidadas dentro del diagrama.
        /// </summary>
        /// <param name="childClass">Pasamos la classBase que anida las clases que se buscan</param>
        /// <returns> devolvemos de forma recursiva en una lista las clases anidadas</returns>
        private List<ClassBase> GetDerivedClassBaseList(ClassBase childClass)
        {
            List<ClassBase> itemList = new List<ClassBase>();
            if (childClass.ClassBases != null)
            {
                foreach (var item in childClass.ClassBases)
                {
                    if (item.ClassBases != null)
                    {
                        itemList.Add(item);
                        itemList.AddRange(GetDerivedClassBaseList(item));
                    }
                    else
                    {
                        itemList.Add(item);
                    }
                }
            }

            return itemList;
        }

#>

<#+
                /// <summary>
        /// Obtenemos el arbol de las ClassBase que derivan recursivamente de alguna ClassBase y que 
        /// corresponden a las formas anidadas dentro del diagrama.
        /// </summary>
        /// <param name="childClass">Pasamos la classBase que anida las clases que se buscan</param>
        /// <returns> devolvemos de forma recursiva en un arbol las clases anidadas</returns>
        private ITree<ClassBase> GetDerivedClassBaseTree(ClassBase childClass)
        {
            //List<ClassBase> itemList = new List<ClassBase>();
            ITree<ClassBase> treeClassesBase = NodeTree<ClassBase>.NewTree();
            if (childClass.ClassBases != null)
            {
                foreach (var item in childClass.ClassBases)
                {
                    if (item.ClassBases != null)
                    {
                        foreach(var derivedItem in item.ClassBases)
                        {
                            treeClassesBase.AddChild(GetDerivedClassBaseTree(derivedItem));
                        }
                    }
                    else
                    {
                        treeClassesBase.AddChild(item);
                    }
                }
            }

            return treeClassesBase;
        }

#>

<#+
/// <sumary>
/// Cuando creamos los constructores de clases que derivan de otras tenemos que incluir 
/// los parametros de la superclase los cuales colocamos despues de los propios.
/// por esa razón nos vemos obligados a construir la lista de parametros en dos tandas.
/// En la primera la de los propios en la segunda los de la superclase.
///</sumary>
 public static string GetConstructorParametersStringTaxonomi(
                                                                ITree<LocalizedBounded> treeApp,    /* arbol de aplicaciones establecido por los diagramas*/
                                                                ClassBase entity,                   /* entidad */
                                                                bool autonumerico ,                 /* tipo id */
                                                                SelectionCriteriaAttributes flag,   /* Selección de criterios */
                                                                int limiteSalto,                    /* Longitud máxima para activar el salto de parametros */
                                                                bool incluirTipo,                   /* Incluir el tipo del parametro. Por ejemplo:incluye string, int etc*/
                                                                int spaceIndent,                    /* Indentación de los parametros cuando se salta */
                                                                bool incluirDefaultValues,          /* incluirDefaultValues */
                                                                bool incluirId,                     /* incluirId */
                                                                bool incluirTargetAssociations,     /* incluirTargetAssociations */
                                                                bool incluirSourceAssociations,     /* incluirSourceAssociations */
                                                                bool pascalCase=false,              /* pascalCase */
                                                                string prefijo=null,                /* prefijo */
                                                                string sufijo=null                  /* sufijo */
                                                            )
    {// comienza el metodo
        ClassBase entitySuperClass = GetSuperEntity(entity); // obtenemos la clase de la que se deriva.
        string superclass = null;
        string subclass = GetConstructorParametersString( 
                                                            entity,                        /* entidad */
                                                            autonumerico ,                 /* tipo id */
                                                            flag,                          /* Selección de criterios */
                                                            limiteSalto,                   /* Longitud máxima para activar el salto de parametros */
                                                            incluirTipo,                   /* Incluir el tipo del parametro. Por ejemplo:incluye string, int etc*/
                                                            spaceIndent,                   /* Indentación de los parametros cuando se salta */
                                                            incluirDefaultValues,          /* incluirDefaultValues */
                                                            incluirId,                     /* incluirId */
                                                            incluirTargetAssociations,     /* incluirTargetAssociations */
                                                            incluirSourceAssociations,     /* incluirSourceAssociations */
                                                            pascalCase,                    /* pascalCase */
                                                            prefijo,                       /* prefijo */
                                                            sufijo                         /* sufijo */
                                                        );
if (entitySuperClass.ReferencedRootEntity != null)
{
    entity = GetClassBaseFromReferencedClassBase(treeApp, entitySuperClass.ReferencedRootEntity);
    if (!IsDerived( entity) )
    superclass = GetConstructorParametersString(
                                                    entity,                        /* entidad */
                                                    autonumerico ,                 /* tipo id */
                                                    flag,                          /* Selección de criterios */
                                                    limiteSalto,                    /* Longitud máxima para activar el salto de parametros */
                                                    incluirTipo,                   /* Incluir el tipo del parametro. Por ejemplo:incluye string, int etc*/
                                                    spaceIndent,                    /* Indentación de los parametros cuando se salta */
                                                    incluirDefaultValues,          /* incluirDefaultValues */
                                                    incluirId,                     /* incluirId */
                                                    incluirTargetAssociations,     /* incluirTargetAssociations */
                                                    incluirSourceAssociations,     /* incluirSourceAssociations */
                                                    pascalCase,                    /* pascalCase */
                                                    prefijo,                       /* prefijo */
                                                    sufijo                         /* sufijo */
                                                ).Trim();
    else
    superclass = GetConstructorParametersStringSuperClasess(
                                                                    entity,                        /* entidad */
                                                                    autonumerico ,                 /* tipo id */
                                                                    flag,                          /* Selección de criterios */
                                                                    limiteSalto,                    /* Longitud máxima para activar el salto de parametros */
                                                                    incluirTipo,                   /* Incluir el tipo del parametro. Por ejemplo:incluye string, int etc*/
                                                                    spaceIndent,                    /* Indentación de los parametros cuando se salta */
                                                                    incluirDefaultValues,          /* incluirDefaultValues */
                                                                    incluirId,                     /* incluirId */
                                                                    incluirTargetAssociations,     /* incluirTargetAssociations */
                                                                    incluirSourceAssociations,     /* incluirSourceAssociations */
                                                                    pascalCase,                    /* pascalCase */
                                                                    prefijo,                       /* prefijo */
                                                                    sufijo                         /* sufijo */
                                                                ).Trim();
}
else
{
        superclass = GetConstructorParametersStringSuperClasess(
                                                                            entity,                        /* entidad */
                                                                            autonumerico ,                 /* tipo id */
                                                                            flag,                          /* Selección de criterios */
                                                                            limiteSalto,                    /* Longitud máxima para activar el salto de parametros */
                                                                            incluirTipo,                   /* Incluir el tipo del parametro. Por ejemplo:incluye string, int etc*/
                                                                            spaceIndent,                    /* Indentación de los parametros cuando se salta */
                                                                            incluirDefaultValues,          /* incluirDefaultValues */
                                                                            incluirId,                     /* incluirId */
                                                                            incluirTargetAssociations,     /* incluirTargetAssociations */
                                                                            incluirSourceAssociations,     /* incluirSourceAssociations */
                                                                            pascalCase,                    /* pascalCase */
                                                                            prefijo,                       /* prefijo */
                                                                            sufijo                         /* sufijo */
                                                                       ).Trim();
}
        return T4Help.joinParams(subclass, superclass);
    }
 #>

<#+ 
///<sumary>
/// Contamos el total de entidades y objetos valor que hay en todos los diagramas relacionados.
///<sumary>
public int GetTotalEntitysAllBoundedContext(ITree<LocalizedBounded> TreeApp)
{
    int contador= 0;

    foreach( INode<LocalizedBounded> context in TreeApp.All.Nodes )
    {
        kayak.MoneyGen.Application boundedContext = context.Data.Context.Value;
        if (boundedContext != null & context.Data.Context.Key != null)
        {
            ITree<ClassBase> boundedContextElements = ReadClassesHierarchie(boundedContext);
            contador =contador + boundedContextElements.All.Nodes.Where(p=> (p.Data is Entity || p.Data is ObjectValue || p.Data is Enumeration) & p.Data.ReferencedRootEntity == null).Count();
        }
    }

    return contador;
}
#>

<#+
/// <sumary> 
/// Nos proprociona el número de relaciones reflexivas que tiene la entidad que pasamos como parametro.
/// Este método no comprueba si existen relaciones de reflexión con composición, las cuales no estan permitidas.
/// ya que esta validación se realiza al crear el contexto de la clase.
/// </sumary>
public static int HasReflexive(ClassBase entity)
    {
        int reflexivescount = 0;
        if (entity != null)
        {
            System.Collections.Generic.IEnumerable<kayak.MoneyGen.Association> SourceLinks = Association.GetLinksToSources(entity).Where(p=> !(p.TargetRolName == null || p.TargetRolName.Trim().Length == 0));
            foreach (var linkC in SourceLinks )
            {
                if (linkC.Target.Equals(entity) & linkC.Source.Equals(entity))
                { 
                    reflexivescount++;
                }
            }
        }

        return reflexivescount;
    }
#>

<#+
///<sumary>
/// Obtenemos una lista de clases base accesibles para el contexto cuyo nombre pasamos como segundo parametro
/// en el primer parametro pasamos el árbol de contextos que tenemos.
/// TODO FALTA POR TERMINAR ESTE METODO.
///<sumary>
public static ITree<ClassBase> GetAccessibleClassBaseTree(ITree<LocalizedBounded> TreeApp, ClassBase cb)
{

    // primero obtenemos la referencia del nodo al que pertenece.
    INode<LocalizedBounded> inodeStart = GetBoundeContextFromClassBase(TreeApp, cb);
    INode<LocalizedBounded> ParentNode;
    ITree<ClassBase> CbTree = NodeTree<ClassBase>.NewTree();

    // luego recorremos hacia atras el árbol desde el nodo obtenido metiendo en el diccionario las clases que tiene cada contexto. 
    foreach( INode<LocalizedBounded> context in inodeStart.All.Nodes )
    {
        kayak.MoneyGen.Application boundedContext = context.Data.Context.Value;
        if (boundedContext != null & context.Data.Context.Key != null)
        {
            CbTree.AddChild( ReadClassesHierarchie(boundedContext) );
            //contador =contador + boundedContextElements.All.Nodes.Where(p=> (p.Data is Entity || p.Data is ObjectValue || p.Data is Enumeration) & p.Data.ReferencedRootEntity == null).Count();
        }
    }
    
    // hasta aqui hemos añadido todos las clases de los boundecontext/modulos hijos a partir del nodo
    //ahora es necesario añadir las clases del sharedkernel al que pertenece si este existe.

    ParentNode = inodeStart;
    while (ParentNode.HasParent )
    {
        ParentNode = ParentNode.Parent;
        if (ParentNode.Data.Context.Value != null & ParentNode.Data.Context.Key != null)
            CbTree.AddChild( ReadClassesHierarchie(ParentNode.Data.Context.Value) );
    }
    return CbTree;
}
#>
<#+
    ///<sumary>
    /// se le pasa el nombre de una clase y el árbol de clases accesibles y se comprueba si dicha clase esta dentro, es decir si esta pertenece o no a alguno de los diagramas.
    /// si no esta dentro del diagrama puede ser una clase que pertenezca a alguna otra dll.
    ///<sumary>
    public static bool IsAnAccessibleClassBase(ITree<ClassBase> accesibleClassTree, string className)
    {
        return accesibleClassTree.All.Nodes.Where( p=> p.Data.Name.Equals(className)).Any();
    }
#>