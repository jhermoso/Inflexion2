<#+
public class UXAppConfigCT : Template
{
    // varibles de la plantilla (coinciden con los parametros)
        public ClassBaseContext cbc; 
		public string projectNamespace; 
		public ITree<BoundedContextMetadata> Skt; 
		public string KindTimeCall;
		ITree<LocalizedBounded> TreeApp;
		DslContextDefinitionDiagram MainDiagram;
    // constructor de la plantilla con parametros
    public UXAppConfigCT(ClassBaseContext  cbc, string projectNamespace, ITree<BoundedContextMetadata> Skt, string kindTimeCall, ITree<LocalizedBounded> treeApp, DslContextDefinitionDiagram mainDiagram)
        {
			this.cbc= cbc; 
			this.projectNamespace = projectNamespace;  
			this.Skt = Skt; 
			this.KindTimeCall = kindTimeCall;
			this.TreeApp = treeApp;
			this.MainDiagram = mainDiagram;
		}

    public override string TransformText()
        {
            // uso de interfaces en las propiedades y por tanto en metodos
            //por defecto se usan interfaces con nhibernate en cualquiera e sus modalidades y no se usan con entityFramework
            string I = (cbc.diagram.ORM.Contains("ibernate"))?"I":"";

            // conceptos propios del projecto en curso
            ProjectConcepts prjCon = new ProjectConcepts(  cbc, projectNamespace, Skt);
            // subplantillas generales
            var cpyrigthTemplate    = new CopyrightHeader(cbc.diagram, cbc.solutionInfo, cbc.entity, T4Help.getLeftStringSlice(this.ToString(), '+', -1).Substring(1));  string cpyrigthText = cpyrigthTemplate.TransformText();
            // subplantillas epsecificas
            var usingTemplate       = new usings( cbc, projectNamespace, Skt);  string usingTxt  = usingTemplate.TransformText(); //solo los shared kernel
#>
<#+
            if(KindTimeCall.Equals("inicio") | KindTimeCall.Equals("soloUna") )
            {
#>
<?xml version="1.0" encoding="utf-8"?>
<!-- Xml generated by a t4 template Inflexion2t4Includes.UX.UXAppConfigCT.tt -->
<configuration>

  <startup>
    <supportedRuntime version="v4.0" sku=".NETFramework,Version=v4.5.2"/>
  </startup>
  <connectionStrings>
  <#+
    foreach( INode<LocalizedBounded> context in TreeApp.All.Nodes )
    {
        kayak.MoneyGen.Application boundedContext = context.Data.Context.Value;
		string bdName = null; 
		if(context.Depth == 0)
		{
			bdName = MainDiagram.SolutionFolderCommon;
		}
		else 
		{
			bdName = context.Data.Context.Key; 
		}

        if (boundedContext != null && bdName != null  ) // si el contexto limitado tiene asociado un diagrama y un nombre lo procesamos.
        {
  #>
    <add name="<#= boundedContext.Product #>.Connection"
    connectionString="<#=boundedContext.ConectionString #>"/>
  <#+
		}
	}
  #>
  </connectionStrings>

    <system.web>
    <compilation debug="true" />
  </system.web>    

<!-- copiar aqui del proyecto del proxy de wcfclient la sección de system.servicemodel-->
<!-- copy here from the wcfclient the section system.servicemodel-->

  <system.serviceModel>
    <bindings>
      <basicHttpBinding>
<#+ 
//foreach(INode<ClassBase> entity in cbc.OwnClassBaseTreeBoundedContext.All.Nodes.Where(p=> p.Data is Entity ))
//{

    foreach( INode<LocalizedBounded> context in TreeApp.All.Nodes )
        {
         kayak.MoneyGen.Application boundedContext = context.Data.Context.Value;
		 string bdName = null; 
		 if(context.Depth == 0)
			{
				bdName = MainDiagram.SolutionFolderCommon;
			}
			else 
			{
				bdName = context.Data.Context.Key; 
			}

         if (boundedContext != null && bdName != null  ) // si el contexto limitado tiene asociado un diagrama y un nombre lo procesamos.
         {
			ITree<ClassBase> boundedContextElements = ReadClassesHierarchie(boundedContext);

            foreach (INode<ClassBase> entity in boundedContextElements.All.Nodes.Where(p=> p.Data is Entity && 
					(( p.Data.InheritanceClassModifier & kayak.MoneyGen.InheritClassKeywords.Abstract) != kayak.MoneyGen.InheritClassKeywords.Abstract &
                                                ( p.Data.InheritanceClassModifier & kayak.MoneyGen.InheritClassKeywords.Public) == kayak.MoneyGen.InheritClassKeywords.Public ))
				 						)
            {



    if (entity.Data.ReferencedRootEntity != null || ( entity.Data.InheritanceClassModifier & kayak.MoneyGen.InheritClassKeywords.Abstract ) == kayak.MoneyGen.InheritClassKeywords.Abstract ) continue;
	if (cbc.IsRoot)
	{
	string entityName =  T4Help.ToPascalCase(T4Help.SecureName(entity.Data.Name));
#>
        <binding name="BasicHttpBinding_I<#= entityName #>Service" />
<#+
			}
		}
    }
}
 #>
      </basicHttpBinding>
    </bindings>
    <client>
<#+
            }
			//empieza el bloque repetición// en este caso no usamos el bloque de repetición sino que rrecoremos las entidades que son root
 #>
<#+ 
//foreach(INode<ClassBase> entity in cbc.OwnClassBaseTreeBoundedContext.All.Nodes.Where(p=> p.Data is Entity ))
//{

    foreach( INode<LocalizedBounded> context in TreeApp.All.Nodes )
        {
         kayak.MoneyGen.Application boundedContext = context.Data.Context.Value;
		 string bdName = null; //GetBoundedContextNameFromTreeAppAndDeep( context.Depth,  context,  MainDiagram);
		 if(context.Depth == 0)
			{
				bdName = MainDiagram.SolutionFolderCommon;
			}
			else 
			{
				bdName = context.Data.Context.Key; 
			}

		string secureBdName = bdName.Replace('\\','.');
        if (boundedContext != null && bdName != null  ) // si el contexto limitado tiene asociado un diagrama y un nombre lo procesamos.
        {
			ITree<ClassBase> boundedContextElements = ReadClassesHierarchie(boundedContext);

			foreach (INode<ClassBase> entity in boundedContextElements.All.Nodes.Where(p=> p.Data is Entity && 
				(( p.Data.InheritanceClassModifier & kayak.MoneyGen.InheritClassKeywords.Abstract) != kayak.MoneyGen.InheritClassKeywords.Abstract &
                                            ( p.Data.InheritanceClassModifier & kayak.MoneyGen.InheritClassKeywords.Public) == kayak.MoneyGen.InheritClassKeywords.Public ))
				 					)
            {


    if (entity.Data.ReferencedRootEntity != null || ( entity.Data.InheritanceClassModifier & kayak.MoneyGen.InheritClassKeywords.Abstract ) == kayak.MoneyGen.InheritClassKeywords.Abstract ) continue;
	if (cbc.IsRoot)
	{
	string entityName =  T4Help.ToPascalCase(T4Help.SecureName(entity.Data.Name));
#>

      <endpoint address="http://localhost:8733/Design_Time_Addresses/<#=cbc.diagram.RootNameSpace #>.<#= secureBdName #>.Application.WcfService/<#= entityName #>Service/"
          binding="basicHttpBinding" bindingConfiguration="BasicHttpBinding_I<#= entityName #>Service"
          contract="<#= entityName #>Reference.I<#= entityName #>Service" name="BasicHttpBinding_I<#= entityName #>Service" />
<#+
			}
		}
    }
}
 #>
<#+
 if(KindTimeCall.Equals("fin")  || KindTimeCall.Equals("soloUna") )
            {
#>
    </client>
  </system.serviceModel>

</configuration>
<#+ } #>
<#+
        return this.GenerationEnvironment.ToString();
    } // end de TransformText
}// end template
#>
